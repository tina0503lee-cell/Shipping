<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>物流配貨系統</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@0.0.4/dist/fontkit.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>

<body class="bg-gray-100 p-4">
    <div id="root"></div>
    <script type="text/babel">
        const { useState } = React;
        const { useEffect } = React;
        const { PDFDocument } = PDFLib;
        const FONT_URL = "https://cdn.jsdelivr.net/gh/googlefonts/noto-cjk@main/Sans/OTF/TraditionalChinese/NotoSansCJKtc-Regular.otf";


        function App() {
            const [excelData, setExcelData] = useState([]);
            const [pdfFiles, setPdfFiles] = useState([]);
            const [offset, setOffset] = useState({ x: 10, y: 30, fontSize: 10 });
            const [fontBuffer, setFontBuffer] = useState(null);

            const fetchFont = async () => {
                try {
                    console.log("fetching font...");
                    const res = await fetch(FONT_URL, { redirect: "follow" });
                    if (!res.ok) throw new Error(`Failed to fetch font: HTTP ${res.status}`);

                    const ct = res.headers.get("content-type") || "";
                    console.log("font content-type:", ct);

                    const ab = await res.arrayBuffer();
                    const bytes = new Uint8Array(ab);
                    if (!bytes.length) throw new Error("Font download returned empty bytes");

                    setFontBuffer(bytes);
                    console.log("font loaded, length:", bytes.length);
                } catch (e) {
                    console.error("fetchFont failed:", e);
                    alert("字型載入失敗，請看 console");
                }
            };

            useEffect(() => {
                fetchFont()
            }, []);

            const handleExcel = (e) => {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const wb = XLSX.read(evt.target.result, { type: 'binary' });
                    const data = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);
                    setExcelData(data);
                };
                reader.readAsBinaryString(e.target.files[0]);
            };

            const process = async () => {
                if (!fontBuffer) return alert("請先 fetch font");
                if (!pdfFiles?.length) return alert("請先上傳 PDF");

                const outPdf = await PDFDocument.create();
                outPdf.registerFontkit(fontkit);

                const myFont = await outPdf.embedFont(fontBuffer, { subset: true });

                const f = pdfFiles[0];
                const bytes = await f.arrayBuffer();

                const srcDoc = await PDFDocument.load(bytes);

                const pdfJS = await pdfjsLib.getDocument({ data: bytes }).promise;

                for (let i = 0; i < srcDoc.getPageCount(); i++) {
                    const srcPage = srcDoc.getPage(i);
                    const { width, height } = srcPage.getSize();
                    const sliceH = (height - 32) / 3;
                    const sliceW = (width - 20) / 2;
                    const pageText = (await (await pdfJS.getPage(i + 1)).getTextContent()).items
                        .map(t => t.str).join("");

                    const ordersInPage = pageText
                        .split('https://www.gamenir.com.tw/ ...')
                        .map(t => t.trim())
                        .filter(t => t.includes('提貨人'));

                    for (let index = 0; index < ordersInPage.length; index++) {
                        const order = ordersInPage[index];

                        const top = height - 16 - (Math.floor(index / 2) * sliceH);
                        const left = index % 2 == 0 ? 10 : sliceW + 10;
                        const bottom = top - sliceH;
                        const right = left + sliceW;

                        const embeddedSlice = await outPdf.embedPage(srcPage, {
                            left,
                            right,
                            bottom,
                            top,
                        });

                        const orderPage = outPdf.addPage();
                        orderPage.drawPage(embeddedSlice, { x: index % 2 == 0 ? -14 : 15, y: height - sliceH, width: sliceW, height: sliceH });

                        let id = "";
                        try {
                            id = order.split('配送編號： ')[1].split('門市')[0].trim();
                        } catch { }
                        
                        const orderExcelCols = id ? excelData.filter(r => r["託運單號"] === id) : [];

                        const baseY = height - sliceH - 30;
                        for (let j = 0; j < orderExcelCols.length; j++) {
                            orderPage.drawText(`${orderExcelCols[j]['產品SKU']}: ${orderExcelCols[j]['產品數量']}`, {
                                x: 18,
                                y: baseY - 18 * (j + 1),
                                size: 12,
                                font: myFont
                            });
                        }

                    }
                }

                saveAs(new Blob([await outPdf.save()]), "processed.pdf");
            };

            return (
                <div className="max-w-lg mx-auto bg-white p-6 rounded-xl shadow-lg">
                    <h1 className="text-xl font-bold mb-4 text-center">7-11 物流配貨系統</h1>

                    <div className="mb-4">
                        <label className="block text-sm font-bold mb-1">1. 訂單 Excel</label>
                        <input type="file" onChange={handleExcel} className="w-full border p-2 rounded" />
                    </div>

                    <div className="mb-4">
                        <label className="block text-sm font-bold mb-1">2. 物流 PDF</label>
                        <input type="file" multiple onChange={e => setPdfFiles(Array.from(e.target.files))} className="w-full border p-2 rounded" />
                    </div>

                    <div className="flex gap-2 mb-4 text-white">
                        <button onClick={() => setOffset({ x: 10, y: 20, fontSize: 12 })} className="flex-1 bg-gray-500 p-2 rounded text-sm">一般模式</button>
                        <button onClick={() => setOffset({ x: 15, y: 50, fontSize: 9 })} className="flex-1 bg-orange-500 p-2 rounded text-sm">7-11模式</button>
                    </div>

                    <button onClick={process} className="w-full bg-blue-600 text-white py-3 rounded-lg font-bold">開始下載 PDF</button>

                    <div id="status">{fontBuffer ? 'font buffer loaded' : 'font buffer not loaded'}</div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>

</body>

</html>
